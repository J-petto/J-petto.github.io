---
title: 12. 자바 기초(5)
date: 2024-08-22 20:49:00 +0900
categories: [개발 공부, 네이버 클라우드 캠프]
tags: [비트 캠프, 네이버 클라우드 캠프, 자바 기초] 
description: 자바의 기초 언어를 공부하자.
---

## java 패키지(package)
클래스를 분류하는 문법 → 폴더로 구현

1. 패키지 명 : 조직명 제품명.역할명
    - 조직명 = domain name 사용
    - 정렬하기 편하게 거꾸로 사용
        - ex. com.microsoft, com.oracle, com.bitcamp …
        - 폴더로 만들기 쉽다.

## 마크 다운(markdown) [링크](https://markdownguide.org/getting-started/)
HTML 태그 보다 더 간결한 방식으로 문서의 형식을 지정하기 위해 만든 포맷

<details markdown=1>
<summary markdown="span">ex. .md</summary>

```markdown
# = 제목1
## = 제목2
내용
```
{: .nolineno}

</details>

<details markdown=1>
<summary markdown="span">ex. .html</summary>

```html
<html>
    <body>
    <h1></h1>
    <h2></h2>
    <p></p>
    </body>
</html>
```
{: .nolineno}

</details>

## 리팩토링?
요구사항 → 코드 작성 → 요구사항 만족 → 코드 정리(리팩토링)

## 연산자
### 1. 산술 연산자 : +, - *, /, %

- 값을 계산하는데 사용
- +(덧셈), -(뺄셈), *(곱셈), /(나눗셈_몫), %(나눗셈_나머지)

### 2. 증감 연산자 : ++, --

- a++, ++a, a--, --a 식으로 사용하며 1씩 +, -한다.

```java
int a = 0;
a1 = a++; //a를 a1에 먼저 담고, ++계산하여 a 증가 => a1 = 0, a = 1
a2 = ++a; //++ 계산하여 a2에 담음 => a2 = 2, a = 2
a3 = a--; //a를 a3에 먼저 담고, --계산하여 a 감소 => a3 = 2, a = 1
a4 = --a; //-- 계산하여 a4에 담음 => a4 = 0, a = 0
```
{: .nolineno}

### 3. 관계 연산자 : <, <=, >, >=, instance of

- 값을 비교할 때 사용. (4. 등가 연산자와 같이해서 비교연산자로 정리됨)
- instanceof는 해당 객체가 지정한 클래스나 인터페이스의 인스턴스인지 여부를 확인함.
- ex.
    
    ```java
    Class Animal{ - }
    Class Dog extends Animal{ - }
    Class Main{
    	public static void main(String args[]){
    		Animal animal = new Animal();
    		Dog dog = new Dog();
    		
    		if (animal instanceof Animal) { true }
                
        if (dog instanceof Dog) { true }
    
    		// dog가 Animal의 인스턴스인지 확인 (상속 관계)
    		if (dog instanceof Animal) { true }
    
    		// animal이 Dog의 인스턴스인지 확인 (false)
    		if (animal instanceof Dog) { false }
        }
    	}
    }
    ```
    

### 4. 등가 연산자 : ==, !=

- 관계 연산자 + 등가 연산자 = 비교연산자

### 5. 논리 연산자 : &&, ||, !, &, |

- 논리값(boolean) 타입에 대해 수행하는 연산자
- & : boolean 값에서 두 개의 논리 값이 모두 true라면 true 반환함
- \| : boolean 값에서 두 개의 값 중 하나라도 true라면 true 반환함
    - **\|| 과 \|, &&과 &의 차이?**   
    a \|| b, a && b → a에서 결과가 확정 되면 뒷라인을 수행하지않는다.   
    a \| b, a & b → a에서 결과가 확정되어도 뒷라인을 수행한다.   
    
    ```java
    boolean a = false;
    boolean b = false;
    
    boolean r = a && (b = true);
    // r은 false이지만 b = true의 내용을 수행하기에 이후 b = true의 값을 가진다.
    // a = false, b = true, r = false
    
    boolean c = b || (a = true);
    // b가 true라 r도 true, 여기서 a = true의 내용도 수행하기 때문에 a = true로 변경된다.
    // a = true, b = true, c = true
    ```
    

### 6. 비트 연산자 : &, |, ^, ~

- 정수(Integer) 타입에 대해 수행하는 연산자
- 비트 값을 비교하여 수행하는 연산자이다.
- ex.
    int a = 0b0110_1100;
    int b = 0b0101_0101;

- int는 8바이트
a = 0000~6byte 0110 1100
b = 0000~6byte 0101 0101
- 위 값을 비트 자리를 비교하여 계산한다.
    1. & = 0000~6vyte 0100 0100 : & 는 두 비트 모두 1일 때 1, 그렇지 않으면 0을 반환 (1, 1 = 1 / 1, 0 = 0 / 0, 0 = 0)
    2. \|  = 0000~6byte 0111 1101 : \| 는 두 비트 중 하나라도 1이면 1, 그렇지 않으면 0을 반환 (1, 1 = 1 / 1, 0 = 1 / 0, 0 = 0)
    3. ^ = 0000~6byte 0011 1001 : ^ 는 두 비트가 다를 때 1, 같으면 0을 반환 (1, 1 = 0 / 1, 0 = 1 / 0, 0 = 1)
    4. ~ = 0110 1100 → 1001 0011 : ~는 두 비트를 반전 시킨다 (0 → 1, 1 → 0)
- 비트 연산자는 파일 권한 등 간단한 권한 등 비교하는 부분에 쓰이면 빠르고 적은 메모리로 응용이 가능하다. (ex05 > 0450 ~0481로 확인해보자)

### 7. 비트 이동 연산자 : \<\<, \>\>, \>\>\>

- 비트를 밀어 계산하는 연산자.
- \<\< : 왼쪽으로 밀어 계산한다. 한칸이 밀릴 때 2의 제곱으로 계산이 된다.   
양수, 음수 상관없이 그냥 왼쪽으로 밀기 때문에  음수가 양수가 되는 일도 있어난다   
    
    ```java
    int i = 1;
    //  [0000 0000 0000 0000 0000 0000 0000 0001]
    System.out.println(i << 1); // i << 2, i << 3
    //   0[000 0000 0000 0000 0000 0000 0000 0001-] = 2 -> - 자리에 0이 채워짐
    //  00[00 0000 0000 0000 0000 0000 0000 0001--] = 4
    // 000[0 0000 0000 0000 0000 0000 0000 0001---] = 8 
    //   1[000 0000 0000 0000 0000 0000 0000 0001-] = -1이었지만 2가됨
    ```
    
- \>\>과 \>\>\>은 오른쪽으로 밀어 계산한다. 한칸이 밀릴 때마다 나누기 2의 제곱으로 계산이 된다.   
\>\>은 양수는 0으로 채우고 음수는 1로 채우는 반면, >>>은 양수, 음수 상관없이 0으로 채운다.
    
    ```java
    int i = 105;
    // [00000000000000000000000001101001]
    System.out.println(i >> 1); // i >> 2, i >> 3
    // [ 000000000000000000000000110100]1 = 52 -> 105 / 2
    // [  000000000000000000000000011010]01 = 26 -> 105 / 4
    // [   00000000000000000000000001101]001 = 13 -> 105 / 8
    
    int i = -87; 
    // [11111111111111111111111110101001]
    System.out.println(i >> 1);
    // [ 1111111111111111111111111010100]1
    // [11111111111111111111111111010100]1 = -44 : 음수이기 때문에 공백을 1로 채워 계산
    System.out.println(i >>> 1);
    // [01111111111111111111111111010100]1 = 2147483604: 음수 상관없이 공백을 1로 채워 계산
    ```
    

### 8. 대입 연사자 : =, +=, -=, *=, /=, %=, &=, |=, ^=, \<\<=, \>\>=, \>\>\>=

- 계산 후 값을 넣는 연산자.
    
    ```java
    int a = 4;
    a += 1; // = 5
    a -= 1; // = 4
    a *= 2; // = 8
    a /= 2; // = 4
    a %= 3; // = 1
    ...
    ```
    

### 9. 삼항 연산자 : 조건 ? 값1 : 값2

- 조건에 따라서 값을 전달받는 연산자.
- 값을 되돌려주기에 반드시 담을 변수가 있어야하며 값을 되돌려주지않는 실행하는 명령어는 값에 들어갈 수 없다.
    
    ```java
    조건 ? System.out.println("true"); : System.out.println("false");
    // 이런 식으로 사용하는 건 불가능하다는 얘기, println은 내부를 살펴봤을 때 값을 반환하지 않는 메서드이다.
    ```
    {: .nolineno}

    - statement vs Expression
        
        ```java
        // 모든 명령문은 statement
        System.out.println("Hello");
        int v = 100;
        m1(); <- Expression
        m2(); <- Expression
        if( - ){ - }
        for( ; ; ) { - }
        void m1( ){ - }
        int m2( ){ - }
        ```
        
        - Statement : 프로그래밍 언어에서 특정 작업을 수행하거나 명령을 실행하는 코드의 기본 단위이다.
        - Expression :  Statement 중 프로그래밍에서 값을 계산하는 코드의 조각. 해당 값은 다양한 데이터 타입을 가짐.

### ! 연산자 우선순위

1. ( ~ )
2. *, /, %
3. +, -
- 우선순위가 같은 경우, 먼저 나온 연산자를 먼저 계산한다.
- ( ) 안에 있는 연산자는 가장 우선순위를 가짐

## 정수와 부동소수점의 계산

1. 정수와 정수의 연산 = 정수
2. 부동소수점과 부동소수점의 연산 = 부동소수점
3. 부동소수점과 정수의 연산 = 부동소수점

## 형변환
### 암시적 형변환 : implicit type conversion(casting)

- 타입이 다를 시 컴파일러가 같은 타입으로 자동 변환하는 것
- (byte, char, short) → int → long → float → double로 자동 형변환이 이뤄짐
- 형변환할 때 기존 변수의 타입을 바꾸는 것이 아닌 임시 변수를 생성하는 것

### 계산 시 타입 참고

1. byte + byte = int
2. char + short = int
    - java에서 byte, char, short는 계산 시 int로 바꿔 계산함. 당연히 결과는 int 타입으로 처리가 됨.
    - 그래서 byte 타입을 가진 변수에는 집어넣지 못함. (byte)(a+b)를 하면 byte로 변환시켜 넣을 수 있다.
3. int(21억 이상) + int(21억 이상) = 오버플로우
    - 오버플로우가 되어 음수로 노출됨.
    - 결과를 아무리 더 큰 단위인 long에 넣어도 결과값인 음수 int를 long에 대입하는 것 밖에 안됨.
    - 처음부터 큰 크기를 쓰자.
4. long(22억 이상) <span style="color: red">!오류</span>
    - 22억 이상의 값을 넣을 때면 반드시 리터럴을 추가해야함.
    - 뒤에 L을 안 붙이면 자동으로 int로 이해 > int의 값을 넘어가버림으로 오류를 출력함

### 명시적 형변환 : explicit type conversion(casting)

- 개발자가 명시적으로 형변환을 하는 것
- ex. (byte)(int + int)

## 암시적 형변환 + 연산자 우선순위

```java
3.2f + 5 / 2L = ?
```
{: .nolineno}

- 우선 연산으로 5 / 2L 계산 → 암시적 형변환은 L을 따라감 = 2
- 다음 3.2f + 2 → 암시적 형변환으로 f를 따라감 = 5.2
- 즉, 우선 연산을 따라갈 때마다 암시적 형변환을 한다.